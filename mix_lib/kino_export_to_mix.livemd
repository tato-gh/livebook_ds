# KinoExportToMix

```elixir
Mix.install([{:kino, "~> 0.14.0"}])
```

## å®Ÿè£…

```elixir
defmodule Kino.ExportToMix do
  use Kino.JS
  use Kino.JS.Live

  def new(env_file) do
    file_path = env_file |> URI.parse() |> Map.get(:path)
    livebook_node = Node.list(:connected) |> hd()
    Kino.JS.Live.new(__MODULE__, %{file_path: file_path, livebook_node: livebook_node})
  end

  @impl true
  def init(data, ctx), do: {:ok, assign(ctx, data: data)}

  @impl true
  def handle_connect(ctx), do: {:ok, %{}, ctx}

  @impl true
  def handle_event("export", _params, ctx) do
    data = ctx.assigns.data

    case export_to_mix(data.file_path, data.livebook_node) do
      {:ok, output_dir} ->
        relative_path = Path.relative_to_cwd(output_dir)
        broadcast_event(ctx, "result", %{
          success: true,
          message: "Successfully exported to: #{relative_path}"
        })

      {:error, reason} ->
        broadcast_event(ctx, "result", %{success: false, message: "Error: #{reason}"})
    end

    {:noreply, ctx}
  end

  defp export_to_mix(file_path, livebook_node) do
    with {:ok, content} <- File.read(file_path),
         {notebook, _} <- :rpc.call(livebook_node, Livebook.LiveMarkdown.Import, :notebook_from_livemd, [content]) do
      # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã‚’æ±ºå®š
      base_name = Path.basename(file_path, ".livemd")
      output_dir = Path.join(Path.dirname(file_path), base_name)

      # ä¾å­˜é–¢ä¿‚ã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŠ½å‡º
      deps_string = extract_deps_string(notebook)
      module_strings = extract_module_strings(notebook)

      # Mixãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
      generate_mix_project(output_dir, base_name, deps_string, module_strings)

      {:ok, output_dir}
    else
      error -> {:error, inspect(error)}
    end
  end

  # setupã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰Mix.install([...])ã®ä¾å­˜é–¢ä¿‚ãƒªã‚¹ãƒˆã‚’æ–‡å­—åˆ—ã¨ã—ã¦æŠ½å‡º
  # kino_export_to_mixã¯é™¤å¤–ã™ã‚‹ï¼ˆLivebookä¸Šã§ã®ã¿å¿…è¦ã€MixåŒ–å¾Œã¯ä¸è¦ï¼‰
  # æˆ»ã‚Šå€¤: String.t() (ä¾‹: "[{:kino, \"~> 0.14.0\"}]")
  defp extract_deps_string(notebook) do
    setup_cells =
      case notebook.setup_section do
        nil -> []
        section -> section.cells
      end

    result = extract_from_cells(setup_cells, &find_mix_install_in_source/1)
    deps_string = List.first(result) || "[]"

    # kino_export_to_mixã‚’é™¤å¤–
    filter_kino_export_to_mix(deps_string)
  end

  # ä¾å­˜é–¢ä¿‚ãƒªã‚¹ãƒˆã‹ã‚‰kino_export_to_mixã‚’é™¤å¤–
  defp filter_kino_export_to_mix(deps_string) do
    case Code.string_to_quoted(deps_string) do
      {:ok, deps_list} when is_list(deps_list) ->
        filtered = Enum.reject(deps_list, fn
          {dep_name, _} when dep_name == :kino_export_to_mix -> true
          dep_name when dep_name == :kino_export_to_mix -> true
          _ -> false
        end)
        Macro.to_string(filtered)

      _ ->
        deps_string
    end
  end

  # å…¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰defmoduleã‚’æ–‡å­—åˆ—ãƒªã‚¹ãƒˆã¨ã—ã¦æŠ½å‡º
  # æˆ»ã‚Šå€¤: [String.t()] (ä¾‹: ["defmodule Foo do ... end", "defmodule Bar do ... end"])
  defp extract_module_strings(notebook) do
    all_cells =
      Enum.flat_map(notebook.sections, fn section -> section.cells end)

    extract_from_cells(all_cells, &find_defmodules_in_source/1)
  end

  # ã‚»ãƒ«ãƒªã‚¹ãƒˆã‹ã‚‰ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡ºã™ã‚‹æ±ç”¨é–¢æ•°
  defp extract_from_cells(cells, extractor_fn) do
    cells
    |> Enum.filter(&elixir_code_cell?/1)
    |> Enum.flat_map(fn cell ->
      case Code.string_to_quoted(cell.source) do
        {:ok, ast} -> extractor_fn.(ast)
        _ -> []
      end
    end)
  end

  defp elixir_code_cell?(%{__struct__: Livebook.Notebook.Cell.Code, language: :elixir}), do: true
  defp elixir_code_cell?(_), do: false

  # ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰Mix.install([...])ã®ä¾å­˜é–¢ä¿‚ãƒªã‚¹ãƒˆã‚’æ–‡å­—åˆ—ã¨ã—ã¦å–å¾—
  defp find_mix_install_in_source(ast) do
    find_in_ast(ast, fn
      {{:., _, [{:__aliases__, _, [:Mix]}, :install]}, _, [deps_list | _]} ->
        {:match, Macro.to_string(deps_list)}

      _ ->
        :no_match
    end)
  end

  # ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰defmoduleã‚’æ–‡å­—åˆ—ãƒªã‚¹ãƒˆã¨ã—ã¦å–å¾—
  defp find_defmodules_in_source(ast) do
    find_in_ast(ast, fn
      {:defmodule, _, _} = node -> {:match, Macro.to_string(node)}
      _ -> :no_match
    end)
  end

  # ASTã‚’å†å¸°çš„ã«æ¢ç´¢ã—ã€ãƒãƒƒãƒãƒ£ãƒ¼é–¢æ•°ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º
  # ãƒãƒƒãƒãƒ£ãƒ¼é–¢æ•°ã¯ {:match, result} | :no_match ã‚’è¿”ã™
  defp find_in_ast(ast, matcher_fn) do
    case ast do
      {:__block__, _, expressions} ->
        Enum.flat_map(expressions, &find_in_ast(&1, matcher_fn))

      node ->
        case matcher_fn.(node) do
          {:match, result} -> [result]
          :no_match -> []
        end
    end
  end

  defp generate_mix_project(output_dir, base_name, deps_string, module_strings) do
    # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
    lib_dir = Path.join(output_dir, "lib")
    File.mkdir_p!(lib_dir)

    # mix.exsã‚’ç”Ÿæˆ
    app_name_str = base_name |> String.replace("-", "_")
    app_name = String.to_atom(app_name_str)
    module_name = Macro.camelize(app_name_str)

    mix_exs_content = """
    defmodule #{module_name}.MixProject do
      use Mix.Project

      def project do
        [
          app: #{inspect(app_name)},
          version: "0.1.0",
          elixir: "~> 1.18",
          deps: deps()
        ]
      end

      defp deps do
        #{deps_string}
      end
    end
    """

    File.write!(Path.join(output_dir, "mix.exs"), mix_exs_content)

    # lib/é…ä¸‹ã«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ
    lib_file_path = Path.join(lib_dir, "#{base_name}.ex")

    lib_content = Enum.join(module_strings, "\n\n")
    File.write!(lib_file_path, lib_content)

    :ok
  end

  asset "main.js" do
    """
    export function init(ctx, data) {
      ctx.importCSS("main.css");

      ctx.root.innerHTML = `
        <div class="export-container">
          <button id="export-btn" class="export-btn">
            ğŸ“¦ Export to Mix Project
          </button>
          <div id="result" class="result-message"></div>
        </div>
      `;

      const btn = ctx.root.querySelector("#export-btn");
      const resultDiv = ctx.root.querySelector("#result");

      btn.addEventListener("click", () => {
        btn.disabled = true;
        btn.textContent = "â³ Exporting...";
        ctx.pushEvent("export", {});
      });

      ctx.handleEvent("result", ({ success, message }) => {
        btn.disabled = false;
        btn.textContent = "ğŸ“¦ Export to Mix Project";

        resultDiv.style.display = "block";
        resultDiv.className = success ? "result-message success" : "result-message error";
        resultDiv.textContent = (success ? "âœ… " : "âŒ ") + message;
      });
    }
    """
  end

  asset "main.css" do
    """
    .export-container {
      padding: 16px;
      background: #f5f5f5;
      border-radius: 8px;
    }

    .export-btn {
      padding: 10px 20px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .result-message {
      margin-top: 12px;
      padding: 8px;
      display: none;
      border-radius: 4px;
    }

    .result-message.success {
      background: #c8e6c9;
      color: #2e7d32;
    }

    .result-message.error {
      background: #ffcdd2;
      color: #c62828;
    }
    """
  end
end
```

## ãƒ©ã‚¤ãƒ–ãƒ©ãƒªåŒ–

ã“ã®å®Ÿè£…è‡ªä½“ã‚’ã©ã“ã‹ã‚‰ã§ã‚‚ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«mixã«ã—ã¦ãŠãã€‚

```elixir
Kino.ExportToMix.new(__ENV__.file)
```
